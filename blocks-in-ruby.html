<!DOCTYPE html>
<html class="no-js" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Блоки в Ruby</title>
<meta content="Что общего и чем отличаются блоки и методы в Ruby, почему блок является замыканием, как используются блоки.
" name="description">
<meta content="2011, Andriy Malyshko, http://nashbridges.me" name="author">
<meta content="width=device-width, initial-scale=1.0" name="viewport">
<link href="/favicon.ico" rel="shortcut icon">
<link href="/stylesheets/site.css" rel="stylesheet">
<link href="/feed.xml" rel="alternate" title="Лента новостей" type="application/atom+xml">
<link href="http://nashbridges.me/blocks-in-ruby" rel="canonical">
<script src="http://yandex.st/modernizr/1.7/modernizr.min.js"></script>
</head>
<body>
<div class="page-container">
<header><h1>Ruby и <dfn title="точка">.</dfn>
</h1>
<nav class="menu"><ul>
<li><a href="/">все статьи</a></li>
<li><a href="/tags">все теги</a></li>
<li><a href="/about">зачем и для кого</a></li>
<li class="atom-feed"><a href="/feed.xml">rss</a></li>
</ul></nav></header><article><h1>Блоки в Ruby</h1>
<section class="metadata"><p><span class="faded">сложность материала: </span>для начинающих</p>
<p><span class="faded">версия Ruby</span>: 1.9</p>
<p><span class="faded">необходимые знания</span>: класс, его атрибуты, создание объекта, интерполяция строк, оператор if, методы puts и require, консоль irb</p>
<span class="faded">теги: </span><ul class="tags">
<li><a rel="tag" href="/tag/ruby">Ruby</a></li>
<li><a rel="tag" href="/tag/block">блок</a></li>
<li><a rel="tag" href="/tag/closure">замыкание</a></li>
<li><a rel="tag" href="/tag/yield">yield</a></li>
<li><a rel="tag" href="/tag/iterator">итератор</a></li>
<li><a rel="tag" href="/tag/loop">цикл</a></li>
<li><a rel="tag" href="/tag/dsl">DSL</a></li>
</ul></section><section class="revision faded"><h3>Послемыслия и работа над ошибками</h3>

  <ul>
<li>добавлен раздел о poetry mode (01.08.11)</li>
  </ul></section><p>Блок является одной из ключевых конструкций языка Ruby, которую необходимо
хорошо понимать и любить, поскольку использование блоков, наряду с грамотным
именованием всех идентификаторов (переменных и т. д.) и вызовами методов
по цепочке, делает ваш код читаемым настолько, насколько может быть читаема
хорошая инструкция на английском.</p>

<section><h2>Когда возникает необходимость в блоках?</h2>

  <p>Представим, вы создали простой класс, описывающий гладиатора:</p>

  <pre><code class="slush_poppies"><span class="Comment"><span class="Comment">#</span> gladiator.rb</span>

<span class="Keyword">class</span> Gladiator
  <span class="Keyword">attr</span> <span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>name</span>

  <span class="Keyword">def</span> <span class="FunctionName">initialize</span>(<span class="Variable">name</span>)
    <span class="Variable"><span class="Variable">@</span>name</span> <span class="Operators">=</span> name
  <span class="Keyword">end</span>

  <span class="Keyword">def</span> <span class="FunctionName">say_hello</span>
    puts <span class="String"><span class="String">"</span>Поклон тебе, Цезарь!<span class="String">"</span></span>
    puts <span class="String"><span class="String">"</span>Идущие на смерть приветствуют тебя!<span class="String">"</span></span>
  <span class="Keyword">end</span>

<span class="Comment">  <span class="Comment">#</span> остальное опустим для краткости</span>
<span class="Comment">  <span class="Comment">#</span> ...</span>
<span class="Keyword">end</span>
</code></pre>

  <p>Пример использования:</p>

  <div class="with-notes">
    <pre><code class="slush_poppies">:<span class="Number">001</span> <span class="Operators">&gt;</span> <span class="Keyword">require</span> <span class="String"><span class="String">"</span>./gladiator<span class="String">"</span></span>
:<span class="Number">002</span> <span class="Operators">&gt;</span> spartak <span class="Operators">=</span> <span class="LibraryClassType">Gladiator</span>.<span class="FunctionName">new</span>(<span class="String"><span class="String">"</span>Спартак<span class="String">"</span></span>)
:<span class="Number">003</span> <span class="Operators">&gt;</span> spartak.<span class="FunctionName">say_hello</span>
Поклон тебе, Цезарь!
Идущие на смерть приветствуют тебя!
 =&gt; <span class="BuiltInConstant">nil</span>
</code></pre>

    <aside><p>Точка в <code>require</code> говорит Ruby о том, что файл надо искать в текущем
  каталоге.</p>
    </aside>
</div>

  <p>Допустим также, что он настолько понравился коллегам-программистам,
что те решили использовать его в своих проектах. Спустя некоторое время
начали приходить письма с просьбами и предложениями. Возьмем, например, это,
из некой страховой компании, где возникла необходимость синхронизовать свою
логику с вашей вот так:</p>

  <pre><code class="slush_poppies"><span class="Keyword">def</span> <span class="FunctionName">say_hello</span>
  puts <span class="String"><span class="String">"</span>Поклон тебе, Цезарь!<span class="String">"</span></span>

<span class="Comment">  <span class="Comment">#</span> процедура составления завещания</span>
<span class="Comment">  <span class="Comment">#</span> ...</span>

  puts <span class="String"><span class="String">"</span>Идущие на смерть приветствуют тебя!<span class="String">"</span></span>
<span class="Keyword">end</span>
</code></pre>

  <p>Сейчас они переписали ваш класс, добавив в <code>say_hello</code>
вызов метода, отвечающий за завещания. Но… это же чертовски неправильно!
<code>say_hello</code> должен, натурально, говорить «хэллоу» и больше ничего. И вообще, это
не забота гладиатора, составлять завещания, его дело воевать.</p>

  <p>Пока вы думаете над проблемой, приходит еще одно письмо, на этот раз от программистов
из самого Pixar! По странному стечению обстоятельств им понадобилось такое:</p>

  <pre><code class="slush_poppies"><span class="Keyword">def</span> <span class="FunctionName">say_hello</span>
  puts <span class="String"><span class="String">"</span>Поклон тебе, Цезарь!<span class="String">"</span></span>

<span class="Comment">  <span class="Comment">#</span> запустить анимацию наклона персонажа вперед</span>
<span class="Comment">  <span class="Comment">#</span> ...</span>

  puts <span class="String"><span class="String">"</span>Идущие на смерть приветствуют тебя!<span class="String">"</span></span>
<span class="Keyword">end</span>
</code></pre>

  <p>Вот было бы хорошо позволить выполнение чужого кода внутри своего
метода! И при этом не задумываться, за что он будет отвечать и насколько сложен.</p>

  <p>Как раз для этого в Ruby используют блоки.</p>
</section><section><h2>Что такое блок?</h2>

  <p>Блок — это произвольный код, который можно передать <em>любому</em> методу в качестве неявного
последнего аргумента. Следует понимать, что при этом блок является особой конструкцией
языка и обособлен от списка явных аргументов метода, что означает следующее:</p>

  <ul>
<li>методу можно передать только один блок;</li>
    <li>он всегда идет в самом конце и вынесен за скобки с аргументами (если они есть);</li>
    <li>его можно задать при вызове любого метода, независимо от того, указаны в
определении метода аргументы или нет.</li>
  </ul>
<p>Код может находиться внутри фигурных скобок <code>{ }</code>
или ключевых слов <code>do end</code>. Что именно использовать — решать вам, потому что
обе конструкции описывают совершенно одинаковые по свойствам блоки.
Обычно в фигурные скобки заключают код, состоящий из одной строки, при
этом метод и его блок записывают на одной строке. Если код блока слишком длинный
или объемный, вместо скобок на строке с вызовом метода оставляют <code>do</code>, а сам код пишут
с новой строки с отступом и в конце «закрывают» его <code>end</code>'ом.</p>

  <p>Посмотрим, как это выглядит на практике:</p>

  <div class="with-notes">
    <pre><code class="slush_poppies">:<span class="Number">004</span> <span class="Operators">&gt;</span> spartak.<span class="FunctionName">say_hello</span> { puts <span class="String"><span class="String">"</span>Отпустите меня домой<span class="String">"</span></span> }
Поклон тебе, Цезарь!
Идущие на смерть приветствуют тебя!
 =&gt; <span class="BuiltInConstant">nil</span>
</code></pre>

    <aside><p>Вас не раздражает этот <code>nil</code> в конце? Его возвращает метод <code>puts</code>.</p>
    </aside>
</div>

  <p>Как видим, Ruby совершенно не возражает, что мы добавили к методу блок, хотя сам
метод ничего о нем не знает! При этом метод выполнился без изменений.
Что, если записать выражение иначе?</p>

  <pre><code class="slush_poppies">:<span class="Number">005</span> <span class="Operators">&gt;</span> spartak.<span class="FunctionName">say_hello</span> <span class="Keyword">do</span>
:<span class="Number">006</span> <span class="Operators">&gt;</span>   puts <span class="String"><span class="String">"</span>Отпустите меня домой<span class="String">"</span></span>
:<span class="Number">007</span>?<span class="Operators">&gt;</span> <span class="Keyword">end</span>
Поклон тебе, Цезарь!
Идущие на смерть приветствуют тебя!
 =&gt; <span class="BuiltInConstant">nil</span>
</code></pre>

  <p>Абсолютно никакой разницы. Но какой толк от блока, который не выполняется?</p>
</section><section><h2>Передача контроля блоку</h2>

  <p>Существует два способа выполнить код блока, переданный методу. В этой статье
рассматривается только один из них — ключевое слово <code>yield</code>.</p>

  <p><code>yield</code> — это часть синтаксиса языка, как и объявление блока (поэтому
ее нельзя переопределить). Когда в теле метода мы вызываем <code>yield</code>, то
подразумеваем следующее: «отдай управление блоку, а когда тот закончит, верни
управление этому методу».</p>

  <p>Попробуйте переписать приветствующий метод так:</p>

  <pre><code class="slush_poppies"><span class="Keyword">class</span> Gladiator
  <span class="Keyword">def</span> <span class="FunctionName">say_hello</span>
    puts <span class="String"><span class="String">"</span>Поклон тебе, Цезарь!<span class="String">"</span></span>
    <span class="Keyword">yield</span>
    puts <span class="String"><span class="String">"</span>Идущие на смерть приветствуют тебя!<span class="String">"</span></span>
  <span class="Keyword">end</span>
<span class="Keyword">end</span>
</code></pre>

  <p>и еще одна попытка передать блок:</p>

  <pre><code class="slush_poppies">:<span class="Number">003</span> <span class="Operators">&gt;</span> spartak.<span class="FunctionName">say_hello</span> { puts <span class="String"><span class="String">"</span>То, что мы делаем в жизни, отзывается в вечности.<span class="String">"</span></span> }
Поклон тебе, Цезарь!
То, что мы делаем в жизни, отзывается в вечности.
Идущие на смерть приветствуют тебя!
 =&gt; <span class="BuiltInConstant">nil</span>
</code></pre>

  <p>Вуаля! Теперь все надоедливые товарищи могут пихать в этот блок, что захочется, и
не мешать вам жить. Ура? Не совсем: попробуйте вызвать метод без блока.</p>

  <pre><code class="slush_poppies">:<span class="Number">004</span> <span class="Operators">&gt;</span> spartak.<span class="FunctionName">say_hello</span>
<span class="Variable">LocalJumpError</span>: no block given (<span class="Keyword">yield</span>)
</code></pre>

  <p>Ошибка! Ruby теперь в обязательном порядке требует от нас блок! В некоторых
случаях без блока действительно никак, но чаще всего логика метода вполне
позволяет обойтись без него, как в этом случае. Поэтому перед вызовом
беспощадного <code>yield</code> следует удостовериться, а есть ли блок, с помощью метода
<code>block_given?</code>:</p>

  <pre><code class="slush_poppies"><span class="Keyword">def</span> <span class="FunctionName">say_hello</span>
  puts <span class="String"><span class="String">"</span>Поклон тебе, Цезарь!<span class="String">"</span></span>
  <span class="Keyword">yield</span> <span class="Keyword">if</span> <span class="Keyword">block_given?</span>
  puts <span class="String"><span class="String">"</span>Идущие на смерть приветствуют тебя!<span class="String">"</span></span>
<span class="Keyword">end</span>

:<span class="Number">003</span> <span class="Operators">&gt;</span> spartak.<span class="FunctionName">say_hello</span>
Поклон тебе, Цезарь!
Идущие на смерть приветствуют тебя!
 =&gt; <span class="BuiltInConstant">nil</span>
</code></pre>
</section><section><h2>Обмен информацией с блоком</h2>

  <p>Только вы расслабились, как ребята из страховой компании стучатся с новой
проблемой. Им нужно вписать в завещание имя гладиатора, но решение «в лоб» не
работает:</p>

  <div class="with-notes">
    <pre><code class="slush_poppies">:<span class="Number">003</span> <span class="Operators">&gt;</span> spartak.<span class="FunctionName">say_hello</span> <span class="Keyword">do</span>
:<span class="Number">004</span> <span class="Operators">&gt;</span>   puts <span class="String"><span class="String">"</span>ЗАВЕЩАНИЕ<span class="String">"</span></span>
:<span class="Number">005</span>?<span class="Operators">&gt;</span>   puts <span class="String"><span class="String">"</span>Я, <span class="String"><span class="String">#{</span>name<span class="String">}</span></span>, настоящим завещаю<span class="String">"</span></span>
:<span class="Number">006</span>?<span class="Operators">&gt;</span> <span class="Keyword">end</span>
Поклон тебе, Цезарь!
ЗАВЕЩАНИЕ
<span class="Variable">NameError</span>: undefined local variable <span class="Operators">or</span> method <span class="String"><span class="String">'</span>name<span class="String">'</span></span> <span class="Keyword">for</span> main<span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>Object</span>
</code></pre>

    <aside><p>В реальном коде они используют вывод в файл, а не консоль.</p>
    </aside>
</div>

  <p>Почему так произошло, несмотря на то, что метод <code>name</code> у класса <code>Gladiator</code>
определен? Дело в том, что хотя блок и вызывается
непосредственно в методе, ему недоступны ни локальные переменные
этого метода (<code>say_hello</code>), ни атрибуты объекта (<code>spartak</code>), метод которого вызывается.</p>

  <p>Эту проблему можно решить несколькими способами. Первый — явно передать блоку
ту информацию, в которой он может нуждаться. Например, предоставить
ему имя гладиатора:</p>

  <pre><code class="slush_poppies"><span class="Keyword">def</span> <span class="FunctionName">say_hello</span>
  puts <span class="String"><span class="String">"</span>Поклон тебе, Цезарь!<span class="String">"</span></span>
  <span class="Keyword">yield</span>(name) <span class="Keyword">if</span> <span class="Keyword">block_given?</span>
  puts <span class="String"><span class="String">"</span>Идущие на смерть приветствуют тебя!<span class="String">"</span></span>
<span class="Keyword">end</span>
</code></pre>

  <p>Зная об этом, страховщики теперь могут писать:</p>

  <div class="with-notes">
    <pre><code class="slush_poppies">:<span class="Number">003</span> <span class="Operators">&gt;</span> spartak.<span class="FunctionName">say_hello</span> <span class="Keyword">do </span>|<span class="Variable">gladiator_name</span>|
:<span class="Number">004</span> <span class="Operators">&gt;</span>   puts <span class="String"><span class="String">"</span>ЗАВЕЩАНИЕ<span class="String">"</span></span>
:<span class="Number">005</span>?<span class="Operators">&gt;</span>   puts <span class="String"><span class="String">"</span>Я, <span class="String"><span class="String">#{</span>gladiator_name<span class="String">}</span></span>, настоящим завещаю<span class="String">"</span></span>
:<span class="Number">006</span>?<span class="Operators">&gt;</span> <span class="Keyword">end</span>
Поклон тебе, Цезарь!
ЗАВЕЩАНИЕ
Я, Спартак, настоящим завещаю
Идущие на смерть приветствуют тебя!
 =&gt; <span class="BuiltInConstant">nil</span>
</code></pre>
    <aside><p><code>gladiator_name</code> — аргумент блока.</p>
    </aside>
</div>

  <p>Чтобы хорошо понять, что тут только что произошло, советую провести для себя
некоторые параллели между блоком и методом. Забегая наперед, скажу, что блок
<em>не является</em> методом, но это не мешает увидеть, что между ними есть много общего.</p>

  <p>У метода есть имя. Назвали имя — вызвали код, описанный в определении метода.
Назвали <code>yield</code> — вызвали код, описанный в блоке.</p>

  <p>Метод может принимать аргументы, если они были указаны в его определении.
Как видно из последнего примера, <code>yield</code> тоже можно вызывать с
аргументами. И было бы логичным ожидать, что в самом блоке нужно как-то указать
перечень принимаемых аргументов.</p>

  <p>Ожидания оправдываются во всём, кроме синтаксиса: вместо круглых скобок, как в
методе, аргументы блока следует брать в прямые <code>| |</code>. После того, как аргумент объявлен,
можно обращаться к нему в блоке, как к локальной переменной. Список
аргументов записывается сразу после <code>do</code> (или <code>{</code>),
перенос строки после него не обязателен.</p>

  <p>Продолжим аналогию. Метод всегда возвращает значение: это или
значение последнего выражения, или значение выражения после ключевого
слова <code>return</code>. Блок тоже возвращает значение, и его можно получить в
методе как результат вызова <code>yield</code>.</p>

  <p>Пусть наш салютующий метод теперь выглядит так:</p>

  <pre><code class="slush_poppies"><span class="Keyword">def</span> <span class="FunctionName">say_hello</span>
  puts <span class="String"><span class="String">"</span>Поклон тебе, Цезарь!<span class="String">"</span></span>
  <span class="Keyword">if</span> <span class="Keyword">block_given?</span>
<span class="Comment">    <span class="Comment">#</span> монетка бросается в блоке</span>
    coin_flip <span class="Operators">=</span> <span class="Keyword">yield</span>(name)
    <span class="Keyword">if</span> coin_flip <span class="Operators">==</span> <span class="Number">1</span>
<span class="Comment">      <span class="Comment">#</span> выпал аверс</span>
      puts <span class="String"><span class="String">"</span>Похоже, мне повезет в этой битве.<span class="String">"</span></span>
    <span class="Keyword">else</span>
      puts <span class="String"><span class="String">"</span>Смерть улыбается всем нам.<span class="String">"</span></span>
    <span class="Keyword">end</span>
  <span class="Keyword">end</span>
  puts <span class="String"><span class="String">"</span>Идущие на смерть приветствуют тебя!<span class="String">"</span></span>
<span class="Keyword">end</span>
</code></pre>

  <p>а его вызов с блоком — так:</p>

  <div class="with-notes">
    <pre><code class="slush_poppies">:<span class="Number">003</span> <span class="Operators">&gt;</span> spartak.<span class="FunctionName">say_hello</span> <span class="Keyword">do </span>|<span class="Variable">gladiator_name</span>|
:<span class="Number">004</span> <span class="Operators">&gt;</span>   puts <span class="String"><span class="String">"</span>-&gt; <span class="String"><span class="String">#{</span>gladiator_name<span class="String">}</span></span> бросает монетку<span class="String">"</span></span>
:<span class="Number">005</span>?<span class="Operators">&gt;</span>   <span class="FunctionName">rand</span>(<span class="Number">2</span>)
:<span class="Number">006</span>?<span class="Operators">&gt;</span> <span class="Keyword">end</span>
Поклон тебе, Цезарь!
<span class="Operators">-</span><span class="Operators">&gt;</span> Спартак бросает монетку
Похоже, мне повезет в этой битве.
Идущие на смерть приветствуют тебя!
 =&gt; <span class="BuiltInConstant">nil</span>
</code></pre>

    <aside><p>Метод <code>rand</code> случайно генерирует 0 или 1. На этот раз Спартаку повезло.</p>
    </aside>
</div>

  <p>Есть у блока с методом еще одно общее свойство: оба они создают новую локальную область
видимости переменных. Другими словами, переменная, объявленная внутри них,
недоступна в других участках выполняемого кода.</p>

  <div class="with-notes">
    <pre><code class="slush_poppies">:<span class="Number">001</span> <span class="Operators">&gt;</span> <span class="Keyword">def</span> <span class="FunctionName">nonsense</span>
:<span class="Number">002</span>?<span class="Operators">&gt;</span>   inside_method <span class="Operators">=</span> <span class="String"><span class="String">"</span>Я существую только внутри метода.<span class="String">"</span></span>
:<span class="Number">003</span>?<span class="Operators">&gt;</span>   <span class="Keyword">yield</span> <span class="Keyword">if</span> <span class="Keyword">block_given?</span>
:<span class="Number">004</span>?<span class="Operators">&gt;</span> <span class="Keyword">end</span>
 =&gt; <span class="BuiltInConstant">nil</span>
:<span class="Number">005</span> <span class="Operators">&gt;</span> nonsense
 =&gt; <span class="BuiltInConstant">nil</span>
:<span class="Number">006</span> <span class="Operators">&gt;</span> puts inside_method
<span class="Variable">NameError</span>: undefined local variable <span class="Operators">or</span> method <span class="String"><span class="String">'</span>inside_method<span class="String">'</span></span> <span class="Keyword">for</span> main<span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>Object</span>
:<span class="Number">007</span> <span class="Operators">&gt;</span> nonsense { inside_block <span class="Operators">=</span> <span class="String"><span class="String">"</span>А я — только внутри блока.<span class="String">"</span></span> }
 =&gt; <span class="String"><span class="String">"</span>А я — только внутри блока.<span class="String">"</span></span>
:<span class="Number">008</span> <span class="Operators">&gt;</span> puts inside_block
<span class="Variable">NameError</span>: undefined local variable <span class="Operators">or</span> method <span class="String"><span class="String">'</span>inside_block<span class="String">'</span></span> <span class="Keyword">for</span> main<span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>Object</span>
</code></pre>

    <aside><p>Тут и далее код, не связанный с классом <code>Gladiator</code>.</p>

      <p>Я вызвал <code>nonsense</code>, чтобы гарантировать создание переменной
  <code>inside_method</code> и показать, что она существует только в момент выполнения метода.</p>
    </aside>
</div>

  <p>Обратите внимание на то, как значение присвоения переменной <code>inside_block</code>
было последовательно возвращено блоком в метод, а затем — самим методом. Впрочем,
это всё равно не сделало саму переменную видимой вне блока.</p>
</section><section><h2>Почему блок нельзя считать анонимным методом?</h2>

  <section><h3>Внешние переменные</h3>

    <p>Основное и принципиальное отличие блока от метода в том, что первый имеет доступ
к переменным, объявленным до него во внешнем окружении.
Теперь вернитесь на пару абзацев назад и подумайте, не отрицает ли это сказанное
выше про локальную область видимости, которую создает блок?</p>

    <p>Оказывается, нет. Даже если внутри блока происходит присвоение переменной, ранее
объявленной не в нем, Ruby не создает локальную переменную, а позволяет
присвоить внешней переменной новое значение.</p>

    <div class="with-notes">
      <pre><code class="slush_poppies">:<span class="Number">001</span> <span class="Operators">&gt;</span> cat <span class="Operators">=</span> <span class="String"><span class="String">"</span>Голодный кот<span class="String">"</span></span>
 =&gt; <span class="String"><span class="String">"</span>Голодный кот<span class="String">"</span></span>
:<span class="Number">002</span> <span class="Operators">&gt;</span> <span class="Keyword">def</span> <span class="FunctionName">locate_cat</span>
:<span class="Number">003</span>?<span class="Operators">&gt;</span>   puts <span class="String"><span class="String">"</span>Кажется, <span class="String"><span class="String">#{</span>cat<span class="String">}</span></span> на крыше.<span class="String">"</span></span>
:<span class="Number">004</span>?<span class="Operators">&gt;</span> <span class="Keyword">end</span>
 =&gt; <span class="BuiltInConstant">nil</span>
:<span class="Number">005</span> <span class="Operators">&gt;</span> locate_cat
<span class="Variable">NameError</span>: undefined local variable <span class="Operators">or</span> method <span class="String"><span class="String">'</span>cat<span class="String">'</span></span> <span class="Keyword">for</span> main<span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>Object</span>
:<span class="Number">006</span> <span class="Operators">&gt;</span> <span class="Keyword">def</span> <span class="FunctionName">whatever</span>
:<span class="Number">007</span>?<span class="Operators">&gt;</span>   <span class="Keyword">yield</span>
:<span class="Number">008</span>?<span class="Operators">&gt;</span> <span class="Keyword">end</span>
 =&gt; <span class="BuiltInConstant">nil</span>
:<span class="Number">009</span> <span class="Operators">&gt;</span> whatever <span class="Keyword">do</span>
:<span class="Number">010</span> <span class="Operators">&gt;</span>   puts <span class="String"><span class="String">"</span><span class="String"><span class="String">#{</span>cat<span class="String">}</span></span> добрался до колбасы!<span class="String">"</span></span>
:<span class="Number">011</span>?<span class="Operators">&gt;</span>   cat <span class="Operators">=</span> <span class="String"><span class="String">"</span>Уже не голодный кот<span class="String">"</span></span>
:<span class="Number">012</span>?<span class="Operators">&gt;</span> <span class="Keyword">end</span>
Голодный кот добрался до колбасы!
 =&gt; <span class="String"><span class="String">"</span>Уже не голодный кот<span class="String">"</span></span>
:<span class="Number">013</span> <span class="Operators">&gt;</span> puts cat
Уже не голодный кот
 =&gt; <span class="BuiltInConstant">nil</span>
</code></pre>

      <aside><p>Метод <code>whatever</code> имеет исключительно академическое значение,
  поскольку занимается только тем, что выполняет любой переданный ему блок.</p>

        <p>Смотрите, как переменная <code>cat</code> «просачивается» внутрь блока и даже меняет
  свое значение.</p>
      </aside>
</div>

    <p>При этом нужно понимать, что блок не может магическим образом видеть <em>все</em>
переменные вне себя. Его способностей хватает только на те, которые
находятся с ним на одном уровне, т. е. не скрыты от него внутри других методов
или блоков, и объявлены на момент выполнения блока.</p>

    <pre><code class="slush_poppies">:<span class="Number">014</span> <span class="Operators">&gt;</span> whatever { dog <span class="Operators">=</span> <span class="String"><span class="String">"</span>Ленивый пёс<span class="String">"</span></span> }
 =&gt; <span class="String"><span class="String">"</span>Ленивый пёс<span class="String">"</span></span>
:<span class="Number">015</span> <span class="Operators">&gt;</span> whatever { puts dog }
<span class="Variable">NameError</span>: undefined local variable <span class="Operators">or</span> method <span class="String"><span class="String">'</span>dog<span class="String">'</span></span> <span class="Keyword">for</span> main<span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>Object</span>
</code></pre>

    <p>Теперь, если вернуться к раннему примеру с завещанием для
гладиатора, можно догадаться, как решить проблему с его именем, не используя
аргументы блока:</p>

    <div class="with-notes">
      <pre><code class="slush_poppies">:<span class="Number">003</span> <span class="Operators">&gt;</span> spartak.<span class="FunctionName">say_hello</span> <span class="Keyword">do</span>
:<span class="Number">004</span> <span class="Operators">&gt;</span>   puts <span class="String"><span class="String">"</span>ЗАВЕЩАНИЕ<span class="String">"</span></span>
:<span class="Number">005</span>?<span class="Operators">&gt;</span>   puts <span class="String"><span class="String">"</span>Я, <span class="String"><span class="String">#{</span>spartak<span class="String"><span class="String">.</span><span class="FunctionName">name</span></span><span class="String">}</span></span>, настоящим завещаю<span class="String">"</span></span>
:<span class="Number">006</span>?<span class="Operators">&gt;</span> <span class="Keyword">end</span>
</code></pre>

      <aside><p>Поскольку переменная <code>spartak</code> объявлена до выполнения блока, совершенно
  не зазорно использовать ее внутри.</p>
      </aside>
</div>
  </section><section><h3>Столкновение переменных</h3>

    <p>Что произойдет, если имя аргумента блока совпадает с внешней переменной? В этом
случае Ruby создаст новую локальную переменную, и внешняя
переменная внутри блока будет недоступна.</p>

    <pre><code class="slush_poppies">:<span class="Number">001</span> <span class="Operators">&gt;</span> <span class="Keyword">def</span> <span class="FunctionName">with_one</span>
:<span class="Number">002</span>?<span class="Operators">&gt;</span>   <span class="Keyword">yield</span>(<span class="Number">1</span>)
:<span class="Number">003</span>?<span class="Operators">&gt;</span> <span class="Keyword">end</span>
:<span class="Number">004</span> <span class="Operators">&gt;</span> number <span class="Operators">=</span> <span class="Number">99</span>
:<span class="Number">005</span> <span class="Operators">&gt;</span> with_one { |<span class="Variable">number</span>| puts <span class="String"><span class="String">"</span>number равно <span class="String"><span class="String">#{</span>number<span class="String">}</span></span><span class="String">"</span></span> }
number равно <span class="Number">1</span>
 =&gt; <span class="BuiltInConstant">nil</span>
:<span class="Number">006</span> <span class="Operators">&gt;</span> puts number
<span class="Number">99</span>
 =&gt; <span class="BuiltInConstant">nil</span>
</code></pre>

    <p>Наконец, а что делать, если вы хотите, чтобы блок <em>не</em> захватывал внутри и
менял внешнюю переменную? Для этого нужно в принудительном порядке создать
одноименную локальную переменную блока, делается это ее указанием после точки
с запятой в списке аргументов:</p>

    <div class="with-notes">
      <pre><code class="slush_poppies">:<span class="Number">006</span> <span class="Operators">&gt;</span> puts number
<span class="Number">99</span>
 =&gt; <span class="BuiltInConstant">nil</span>
:<span class="Number">007</span> <span class="Operators">&gt;</span> with_one <span class="Keyword">do </span>|<span class="Variable">i</span>; <span class="Variable">number</span>|
:<span class="Number">008</span> <span class="Operators">&gt;</span>   puts <span class="String"><span class="String">"</span>i равно <span class="String"><span class="String">#{</span>i<span class="String">}</span></span><span class="String">"</span></span>
:<span class="Number">009</span>?<span class="Operators">&gt;</span>   number <span class="Operators">=</span> <span class="Number">123</span>
:<span class="Number">010</span>?<span class="Operators">&gt;</span> <span class="Keyword">end</span>
i равно <span class="Number">1</span>
 =&gt; <span class="Number">123</span>
:<span class="Number">011</span> <span class="Operators">&gt;</span> puts number
<span class="Number">99</span>
 =&gt; <span class="BuiltInConstant">nil</span>
</code></pre>

      <aside><p><code>with_one</code> по-прежнему передает в блок единицу.</p>
      </aside>
</div>
  </section><section><h3>Как это использовать?</h3>

    <p>Поначалу может показаться, что всё это жадное «захватывание» переменных блоком
(поэтому блоки еще называют <em>замыканиями</em>) не имеет никакого смысла,
если не хуже — представляет опасность: можно очень легко изменить
переменную, полагая, что работаешь с ней только внутри блока.</p>

    <p>На самом деле,
практическое применение замыканий становится понятным, только когда их
начинают <em>перемещать между областями видимости</em>, что выходит за рамки данной
статьи. Поэтому пока что стоит принять на веру, что замыкание — полезная штука,
если работать с ней аккуратно.</p>
  </section><section><h3>Как метод и блок считают аргументы</h3>

    <p>В этом еще одно отличие: метод слишком ворчливый и дотошный, он требует строгого
соответствия заявленного и предоставленного количества аргументов. Блок же
закрывает глаза на недостачу и даже на избыток аргументов!</p>

    <div class="with-notes">
      <pre><code class="slush_poppies">:<span class="Number">001</span> <span class="Operators">&gt;</span> <span class="Keyword">def</span> <span class="FunctionName">feed_crocodile</span>(<span class="Variable">name</span>)
:<span class="Number">002</span>?<span class="Operators">&gt;</span>   puts <span class="String"><span class="String">"</span>Сейчас будем кормить крокодила <span class="String"><span class="String">#{</span>name<span class="String">}</span></span><span class="String">"</span></span>
:<span class="Number">003</span>?<span class="Operators">&gt;</span>   <span class="Keyword">yield</span>(name) <span class="Keyword">if</span> <span class="Keyword">block_given?</span>
:<span class="Number">004</span>?<span class="Operators">&gt;</span> <span class="Keyword">end</span>
 =&gt; <span class="BuiltInConstant">nil</span>
:<span class="Number">005</span> <span class="Operators">&gt;</span> <span class="FunctionName">feed_crocodile</span>(<span class="String"><span class="String">"</span>Тотошку<span class="String">"</span></span>)
Сейчас будем кормить крокодила Тотошку
 =&gt; <span class="BuiltInConstant">nil</span>
:<span class="Number">006</span> <span class="Operators">&gt;</span> feed_crocodile
<span class="Variable">ArgumentError</span>: wrong number of arguments (<span class="Number">0</span> <span class="Keyword">for</span> <span class="Number">1</span>)
:<span class="Number">007</span> <span class="Operators">&gt;</span> <span class="FunctionName">feed_crocodile</span>(<span class="String"><span class="String">"</span>Тотошку<span class="String">"</span></span>, <span class="String"><span class="String">"</span>бананами<span class="String">"</span></span>)
<span class="Variable">ArgumentError</span>: wrong number of arguments (<span class="Number">2</span> <span class="Keyword">for</span> <span class="Number">1</span>)
:<span class="Number">008</span> <span class="Operators">&gt;</span> <span class="FunctionName">feed_crocodile</span>(<span class="String"><span class="String">"</span>Тотошку<span class="String">"</span></span>) { |<span class="Variable">name</span>| puts <span class="String"><span class="String">"</span><span class="String"><span class="String">#{</span>name<span class="String">}</span></span> кормят мясом!<span class="String">"</span></span> }
Сейчас будем кормить крокодила Тотошку
Тотошку кормят мясом!
 =&gt; <span class="BuiltInConstant">nil</span>
:<span class="Number">009</span> <span class="Operators">&gt;</span> <span class="FunctionName">feed_crocodile</span>(<span class="String"><span class="String">"</span>Тотошку<span class="String">"</span></span>) { puts <span class="String"><span class="String">"</span>Два дня не ел, бедняга<span class="String">"</span></span> }
Сейчас будем кормить крокодила Тотошку
Два дня не ел, бедняга
 =&gt; <span class="BuiltInConstant">nil</span>
:<span class="Number">010</span> <span class="Operators">&gt;</span> <span class="FunctionName">feed_crocodile</span>(<span class="String"><span class="String">"</span>Тотошку<span class="String">"</span></span>) { |<span class="Variable">name</span>, <span class="Variable">food</span>| puts <span class="String"><span class="String">"</span><span class="String"><span class="String">#{</span>name<span class="String">}</span></span> кормят <span class="String"><span class="String">#{</span>food<span class="String">}</span></span>!<span class="String">"</span></span> }
Сейчас будем кормить крокодила Тотошку
Тотошку кормят <span class="Operators">!</span>
 =&gt; <span class="BuiltInConstant">nil</span>
</code></pre>

      <aside><p>Всё внимание на второй и третий вызов с блоком: ошибок нет!</p>

        <p>Во втором мы вообще забыли указать список аргументов. Переданное в блок <code>name</code>
  считаем выброшенным в пропасть.</p>

        <p>В третьем мы объявили лишний аргумент. В этом случае Ruby создает локальную
  переменную <code>food</code> и присваивает ей значение <code>nil</code>, которое при
  интерполяции превращается в пустую строку. Поэтому последний вывод выглядит
  так: «кормят пробел восклицательный знак».</p>
      </aside>
</div>

  </section></section><section><h2>Нечто, похожее на блоки</h2>

  <p>Существует ряд операторов в Ruby, в которых используются ключевые слова
<code>do end</code> — это циклы <code>while</code>, <code>until</code>, <code>for</code>. Хочется предостеречь
от возможного заблуждения: в них <em>не используются</em> блоки, <code>do end</code> являются
неотъемлемой составляющей конструкции этих операторов.</p>

  <p>Во-первых, хотя и пишем</p>

  <pre><code class="slush_poppies">:<span class="Number">001</span> <span class="Operators">&gt;</span> <span class="Keyword">for</span> i <span class="Keyword">in</span> [<span class="Number">1</span>, <span class="Number">2</span>, <span class="Number">3</span>] <span class="Keyword">do</span>
:<span class="Number">002</span> <span class="Operators">&gt;</span>   print i
:<span class="Number">003</span>?<span class="Operators">&gt;</span> <span class="Keyword">end</span>
<span class="Number">123</span> =&gt; [<span class="Number">1</span>, <span class="Number">2</span>, <span class="Number">3</span>]
</code></pre>

  <p>но не получится написать</p>

  <pre><code class="slush_poppies"><span class="Keyword">for</span> i <span class="Keyword">in</span> [<span class="Number">1</span>, <span class="Number">2</span>, <span class="Number">3</span>] { print i }
</code></pre>

  <p>Во-вторых, операторы циклов не создают локальную область видимости:</p>

  <pre><code class="slush_poppies">:<span class="Number">001</span> <span class="Operators">&gt;</span> x <span class="Operators">=</span> <span class="Number">0</span>
 =&gt; <span class="Number">0</span>
:<span class="Number">002</span> <span class="Operators">&gt;</span> <span class="Keyword">while</span> x <span class="Operators">&lt;</span> <span class="Number">1</span> <span class="Keyword">do</span>
:<span class="Number">003</span> <span class="Operators">&gt;</span>   inside <span class="Operators">=</span> <span class="String"><span class="String">"</span>Я внутри?<span class="String">"</span></span>
:<span class="Number">004</span>?<span class="Operators">&gt;</span>   x <span class="Operators">+=</span> <span class="Number">1</span>
:<span class="Number">005</span>?<span class="Operators">&gt;</span> <span class="Keyword">end</span>
 =&gt; <span class="BuiltInConstant">nil</span>
:<span class="Number">006</span> <span class="Operators">&gt;</span> puts inside
Я внутри?
 =&gt; <span class="BuiltInConstant">nil</span>
</code></pre>

  <p>В то же время <code>loop</code>, реализующий бесконечный цикл, является системным методом,
который как раз принимает блоки:</p>

  <pre><code class="slush_poppies"><span class="Keyword">loop</span> { print <span class="String"><span class="String">"</span>кольцокольцо<span class="String">"</span></span> }
</code></pre>
</section><section><h2>Поэтичный стиль и блоки</h2>

  <p>Поэтичным стилем (<em>poetry mode</em>) в Ruby называют стиль написания кода, при котором
опускают скобки в тех местах, где анализатор может предположить их наличие, исходя
из контекста. В основном это касается аргументов при вызове метода:</p>

  <pre><code class="slush_poppies"><span class="FunctionName">puts</span>(<span class="String"><span class="String">"</span>Hello<span class="String">"</span></span>) <span class="Comment"><span class="Comment">#</span> классический стиль</span>
puts <span class="String"><span class="String">"</span>Hello<span class="String">"</span></span>  <span class="Comment"><span class="Comment">#</span> poetry mode</span>
</code></pre>

  <h3>Разница между <code>{ }</code> и <code>do end</code>
</h3>

  <p>Фигурные скобки блоков имеют более высокий приоритет при разборе выражения, чем ключевые
слова <code>do end</code>. На практике это имеет значение только и именно в тех случаях, когда
используется поэтичный стиль.</p>

  <p>Допустим, есть метод <code>kick_ass</code>, который принимает в качестве единственного
аргумента имя того, кому мы хотим надрать задницу. Тогда запись</p>

  <pre><code class="slush_poppies">kick_ass <span class="String"><span class="String">"</span>Джокер<span class="String">"</span></span> <span class="Keyword">do</span>
  puts <span class="String"><span class="String">"</span>Ты будешь сидеть в камере психушки вечно.<span class="String">"</span></span>
<span class="Keyword">end</span>
</code></pre>

  <p>будет прочитана Ruby именно так, как вы задумали:</p>

  <pre><code class="slush_poppies"><span class="FunctionName">kick_ass</span>(<span class="String"><span class="String">"</span>Джокер<span class="String">"</span></span>) <span class="Keyword">do</span>
  puts <span class="String"><span class="String">"</span>Ты будешь сидеть в камере психушки вечно.<span class="String">"</span></span>
<span class="Keyword">end</span>
</code></pre>

  <p>А вот вызов метода с блоком в фигурных скобках</p>

  <pre><code class="slush_poppies">kick_ass <span class="String"><span class="String">"</span>Бэтмен<span class="String">"</span></span> { puts <span class="String"><span class="String">"</span>Если умеешь что-то, не делай этого бесплатно.<span class="String">"</span></span> }
</code></pre>

  <p>Ruby поймет — внимание! — как:</p>

  <pre><code class="slush_poppies"><span class="FunctionName">kick_ass</span>(<span class="String"><span class="String">"</span>Бэтмен<span class="String">"</span></span> { puts <span class="String"><span class="String">"</span>Если умеешь что-то, не делай этого бесплатно.<span class="String">"</span></span> })
</code></pre>

  <p>Фактически вы пытаетесь передать блок строке, и это, конечно же, приведет к
ошибке. Вывод: ставьте скобки в сложных выражениях.</p>

  <h3>Блок и хеш</h3>

  <p>Так получилось, что у блока и хеша одинаковая нотация: фигурные скобки.
Поэтому, если попытаться передать последний в качестве аргумента, не взяв в
круглые скобки, Ruby примет его за блок, и выдаст ошибку. Если сохранять стиль,
нужно опустить и фигурные скобки:</p>

  <pre><code class="slush_poppies">kick_ass { <span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>joker</span> =&gt; <span class="String"><span class="String">"</span>2 раза<span class="String">"</span></span>, <span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>penguin</span> =&gt; <span class="String"><span class="String">"</span>1 раз<span class="String">"</span></span> } <span class="Comment"><span class="Comment">#</span> синтаксическая ошибка</span>
kick_ass <span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>joker</span> =&gt; <span class="String"><span class="String">"</span>2 раза<span class="String">"</span></span>, <span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>penguin</span> =&gt; <span class="String"><span class="String">"</span>1 раз<span class="String">"</span></span>     <span class="Comment"><span class="Comment">#</span> так всё нормально</span>
</code></pre>

  <p>Наконец, если вам нужно передать методу и хеш, и блок, или используйте
исключительно <code>do end</code>, или забудьте о поэтичном стиле и берите аргументы в
скобки, как положено.</p>

</section><section><h2>Использование блоков в повседневном коде</h2>

  <section><h3>Итераторы</h3>

    <p>Трудно себе представить рабочий код на Ruby без применения итераторов. Вся работа
с массивами, хешами и другими объектами, способными себя перечислять, построена на итераторах,
что намного удобнее использования циклов.</p>

    <p>Итератор — это метод, который некоторое количество раз
вызывает блок и может передавать в него данные по определенному алгоритму.
Итератор без блока — как туловище без головы: он знает, с чем ему нужно
работать, но абсолютно без понятия, <em>что</em> ему нужно с этим делать.</p>

    <p>Самый известный итератор, <code>each</code>, последовательно передает в блок все
элементы объекта, от имени которого вызван метод.</p>

    <pre><code class="slush_poppies">:<span class="Number">001</span> <span class="Operators">&gt;</span> [<span class="Number">1</span>, <span class="Number">2</span>, <span class="Number">3</span>].<span class="FunctionName">each</span> { |<span class="Variable">i</span>| puts i <span class="Operators">+</span> <span class="Number">2</span> }
<span class="Number">3</span>
<span class="Number">4</span>
<span class="Number">5</span>
 =&gt; <span class="BuiltInConstant">nil</span>
</code></pre>
  </section><section><h3>Обёртывание кода</h3>

    <p>Случается, что какой-то алгоритм состоит из множества типовых операций, между
которыми необходимо выполнять уникальную. Если вы часто едите бутерброды, то
знаете, что хлеб придется нарезать каждый раз, отличие только в начинке.</p>

    <p>Чтобы скрыть рутинные операции, связанные с покупкой хлеба, поиском ножа и
нарезанием, вы оставляете их в методе, а подготовку колбасы — единственную уникальную
операцию — предоставляете блоку, и только он будет у вас постоянно на виду. Это
здорово повышает читаемость кода.</p>

    <p>Классическим примером является работа с файлами с помощью системного
класса <code>File</code>. Метод <code>open</code> этого класса берет на себя заботу
о создании дескриптора открытого файла и — главное — корректном
закрытии файла в конце, пользователю же остается только самое важное —
считывание и обработка данных, находящихся в файле.</p>

    <pre><code class="slush_poppies">:<span class="Number">001</span> <span class="Operators">&gt;</span> first_line <span class="Operators">=</span> <span class="LibraryClassType">File</span>.<span class="FunctionName">open</span>(<span class="String"><span class="String">"</span>some.txt<span class="String">"</span></span>) <span class="Keyword">do </span>|<span class="Variable">file</span>|
:<span class="Number">002</span> <span class="Operators">&gt;</span>   file.<span class="FunctionName">readline</span>
:<span class="Number">003</span>?<span class="Operators">&gt;</span> <span class="Keyword">end</span>
</code></pre>

    <p>Бывает и обратная ситуация: когда вы хотите выполнить что-то
перед или после постороннего метода. Для этого создается служебный
метод, в котором будет выполняться это «что-то» и происходить вызов блока. Теперь
достаточно передать посторонний метод в блоке вашему служебному методу.</p>

    <p>Классическим примером является измерение времени выполнения метода:</p>

    <pre><code class="slush_poppies"><span class="Keyword">def</span> <span class="FunctionName">measure_time</span>
<span class="Comment">  <span class="Comment">#</span> запустить таймер</span>
<span class="Comment">  <span class="Comment">#</span> ...</span>

  <span class="Keyword">yield</span>

<span class="Comment">  <span class="Comment">#</span> остановить таймер и вывести потраченное время</span>
<span class="Comment">  <span class="Comment">#</span> ...</span>
<span class="Keyword">end</span>

measure_time { make_coffee }
</code></pre>
  </section><section><h3>DSL</h3>

    <p>Если вы едите бутерброды каждый день, вполне возможно, вам захочется
написать для этого целую библиотеку. В ней будет много-много методов, вроде
«намазать», «нарезать» и «открыть», каждый из которых будет представлять собой
низкоуровневый код на обычном Ruby. С этим кодом вполне можно работать и напрямую, но
чтобы разобраться в алгоритме работы в контексте поставленной задачи, нужно
напрячься. Другое дело — такая вот инструкция, всё строго по делу:</p>

    <pre><code class="slush_poppies">slices <span class="Operators">=</span> cut bread { by <span class="Number">3</span>, <span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>slices</span> }
open caviar_can, <span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>with</span> =&gt; <span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>can_opener</span> <span class="Keyword">do </span>|<span class="Variable">contents</span>|
  slices.<span class="FunctionName">each</span> { |<span class="Variable">slice</span>| slice.<span class="FunctionName">spread</span> <span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>with</span> =&gt; contents.<span class="FunctionName">about</span>(<span class="String"><span class="String">'</span>20%<span class="String">'</span></span>) }
<span class="Keyword">end</span>
</code></pre>

    <p>Ваш код остался синтаксически правильной последовательностью методов и блоков
Ruby, но с точки зрения решения поставленной задачи — это уже надстройка над
языком или <abbr title="Domain specific language">DSL</abbr>, а методы —
операторы нового языка. Программы,
написанные с помощью хорошо продуманного DSL, легко читать, они говорят сами за себя (отпадает
необходимость в комментировании кода). Но надо понимать, что для каждой
задачи потребуется свой DSL, на изучение/создание которого необходимо время.</p>

    <p>Классическим примером DSL является фреймворк для тестирования <a href="http://www.relishapp.com/rspec/rspec-core">RSpec</a>.</p>
  </section><section><h3>Конструктор объекта</h3>

    <p>Иногда конструктор объекта должен принять столько различных параметров, что
передача их через список аргументов уже неудобна: легко запутаться, что чему
мы присваиваем. Одним из вариантов решения этой проблемы является использование
хеша {название параметра =&gt; значение параметра, …}.</p>

    <p>А можно использовать технику барона Мюнхгаузена: передать в блок конструктора
самого себя, т. е. только что созданный объект, которому уже присваивать нужные
параметры.</p>

    <pre><code class="slush_poppies"><span class="Keyword">class</span> Gladiator
  <span class="Keyword">attr_accessor</span> <span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>name</span>, <span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>rank</span>, <span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>height</span>, <span class="UserDefinedConstant"><span class="UserDefinedConstant">:</span>weight</span>

  <span class="Keyword">def</span> <span class="FunctionName">initialize</span>
    <span class="Keyword">yield</span>(self)
  <span class="Keyword">end</span>

<span class="Comment">  <span class="Comment">#</span>...</span>
<span class="Keyword">end</span>

spartak <span class="Operators">=</span> <span class="LibraryClassType">Gladiator</span>.<span class="FunctionName">new</span> <span class="Keyword">do </span>|<span class="Variable">his</span>|
  his.<span class="FunctionName">name</span> <span class="Operators">=</span> <span class="String"><span class="String">"</span>Спартак<span class="String">"</span></span>
  his.<span class="FunctionName">weight</span> <span class="Operators">=</span> <span class="Number">91</span>
<span class="Keyword">end</span>
</code></pre>
  </section></section></article><footer><hr>
<section class="feedback"><div class="recommend">Порекомендуйте этот материал, если он вам понравился: <div class="google"><div class="g-plusone" data-lang="ru"></div></div>
</div>
<p>Если вы нашли в статье ошибку или опечатку, пожалуйста, сообщите об этом на<strong> you-are-wrong@nashbridges.me</strong></p></section><nav class="menu"><ul>
<li><a href="/">все статьи</a></li>
<li><a href="/tags">все теги</a></li>
<li><a href="/about">зачем и для кого</a></li>
<li class="atom-feed"><a href="/feed.xml">rss</a></li>
</ul></nav><section class="signature"><p><a href="/author">Андрей Малышко</a>, 26.07.2011</p></section></footer>
</div>
<script>var _gaq=[['_setAccount','UA-24784248-1'],['_trackPageview']];
(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
s.parentNode.insertBefore(g,s)}(document,'script'));</script><script src="https://apis.google.com/js/plusone.js"></script>
</body>
</html>
